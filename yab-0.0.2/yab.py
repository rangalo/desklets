#! /usr/bin/env python
"""
--------------------------------------------------------------------------------
Copyright (C) 2005 Sylvain Fourmanoit <syfou@users.sourceforge.net>
	for the code

Copyright (C) 2005 Mike Pirnat <exilejedi@users.sourceforge.net>
	for some ideas, especially configuration-related, see
        configfile.py

Copyright (C) 2004 Lila Community (http://lila-theme.uni.cc/)
        for ALL the included iconic artwork
        
Released under the GPL, version 2. Except the artwork, which is released
pursuant to the restrictions imposed by their authors.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies of the Software and its documentation and acknowledgment shall be
given in the documentation and software packages that this Software was
used.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.   

--------------------------------------------------------------------------------
This was built on python 2.4.0 final, on a linux 2.6.10 glibc 2.3.4
x86 machine. Just run this script from its final location on you disk to
start the desklet. See README for details.

*** DO NOT edit this file for changing the configuration; edit instead
`config.txt' in this directory ***

--------------------------------------------------------------------------------
"""

#-------------------------------------------------------------------------------
import adesklets

from time import time,sleep
from os.path import dirname, join
from os import getenv, spawnlp, P_NOWAIT

#-------------------------------------------------------------------------------
class Config(adesklets.ConfigFile):
    """
================================================================================
    This is the configuration file for the adesklets' desklet
    `Yet Another Bar' (yab).

    You may specify here, for each yab instance you use,
    what icons should be loaded (stored under `icons/' by default,
    but absolute path names are also valid), what commands they should trigger,
    what the captions should be, what font to use, how generating effects,
    etc.

    See `config.txt.minimal' in this directory for the configuration
    of the completely static (all effects turned off) version of the
    default bar with some explanations.

    There is no real need for a long explanation here, since
    a lot of yab configuration parameters are self explanatory.
    Let us just mention here some specific, less obvious elements:

    - colors are expressed as packed RGB hexadecimal on 24 bits
    (1 unsigned byte per channel), as you can use within HTML documents
    for instance: '000000' is pure black, while 'FFFFFF' is pure white.

    - similarily, opacities are given as unsigned one byte decimal
    integer value (hence in [0, 255])

    - gradient_angle is given in degree, not radians, with 0 degrees being
    vertical from top to bottom and going clockwise from there.
    
    - all parameters expressing times are in seconds. On most systems,
    resulting timing of less than 10 milliseconds are not reliable and
    should be avoided.
    
    - many parameters can be set to None, zero or similar values, resulting
    in a more frugal, less dynamic desklet - see `config.txt.minimal' for
    a more complete exemplification of this.

    - the 'click_effect' parameter, if not set to None, is an imlib2
    dynamic filter expression that will get applied to the icon you just
    clicked on for 'click_effect_duration' seconds before being discarded.
    See your imlib2 documentation for details.

    - the 'icon_maximize_threshold' specifies at what fraction of maximal
    size the icon under the pointer should be displayed as completly
    maximized (set to 90% by default). It gives a way to define a 'hot zone'
    around the icon center's x coordinate in which the pointer can move
    and the icon stay stuck on its maximum size anyway. Setting this
    to 0 would make an icon being maximized as soon as the pointer
    get over it, and setting it to 1 to never get 'pinned' on maximum
    size as long as the pointer does not reach its very center
    (thus being smoothly resized from the minimal to the maximal size).

    - all configuration parameters are handled the 'pythonic way', meaning
    that as few checkups as possible are performed, invalid entries leading
    to runtime exceptions being raised. For instance, building a bar
    longer than its screen width will raise a 'did not resize window' error.

    So, whenever you run into trouble configuring a yab instance, you should:

    	* Kill all adesklets instances running:

    		killall -9 adesklets

    	* Restart the troublemaker from the console using
        (XXX being its ID number):
    
    		ADESKLETS_ID=XXX python yab.py	

        * Look at the error output to figure things out.

    Finally, please note that destroying this config file while no yab instances
    are running will force its repopulation with valid default
    entries on yap's desklets restart.
    
    === Special note on icons ===
    
    Only a few icons are shipped with yab (five, actually).
    In case you are wondering, they all come from the Lila theme
    resources (http://lila-theme.uni.cc/). If you go hunting
    for more iconographic artwork, http://www.kde-look.org/
    is also a good start point.
================================================================================
    """
    cfg_default={'icons':[('emacs.png', 'GNU Emacs', 'emacs'),
                          ('firefox.png', 'Firefox', 'firefox'),
                          ('gimp.png', 'The GIMP', 'gimp-2.0'),
                          ('terminal.png', 'Terminal', 'xterm'),
                          ('xmms.png', 'XMMS', 'xmms')],
                 'caption_font':'Vera',
                 'caption_size': 20,
                 'caption_color' : 'AAAAAA',
                 'caption_above' : True,
                 'caption_delay' : .1,
                 'caption_fade_in' : True,
                 'caption_fade_in_duration': .5,
                 'caption_fade_in_steps': 10,
                 'icon_min_width': 64,
                 'icon_min_height': 64,
                 'icon_max_width' : 128,
                 'icon_max_height': 128,
                 'icon_spacing': 5,
                 'icon_maximize_threshold': 0.9,
                 'bar_height': 32,
                 'bar_foreground' : '000000',
                 'bar_background_1': 'AAAAAA',
                 'bar_opacity_1'   : 100,
                 'bar_background_2': None,
                 'bar_opacity_2'   : None,
                 'bar_gradient_angle': 0,
                 'click_effect': \
                 	'tint(alpha=100,red=255,green=255,blue=255);',
                 'click_effect_duration': .1
                 }

    def __init__(self,id,filename):
        adesklets.ConfigFile.__init__(self,id,filename)

    def color(self,string):
        return [eval('0x%s' % string[i*2:i*2+2]) for i in range(len(string)/2)]

#-------------------------------------------------------------------------------
class Events(adesklets.Events_handler):
    """
    The events driving class
    """
    config = None
    icons = []

#--- desklet high-level initialisation -----------------------------------------
    def __init__(self,basedir):
        if len(basedir)==0:
            self.basedir='.'
        else:
            self.basedir=basedir
        adesklets.Events_handler.__init__(self)
        self._active=-1
        self._active_width=0
        self._active_height=0
        self._moved=False
        
    def __del__(self):
        adesklets.Events_handler.__del__(self)

    def ready(self):
        # Real initialisation take place here.
        #
        self.config=Config(adesklets.get_id(),
                           join(self.basedir,'config.txt'))

        # Load all the icons, and retrieve size
        #
        for icon, caption, command in self.config['icons']:
            adesklets.context_set_image(
                adesklets.load_image(join(self.basedir,'icons',icon)))
            self.icons.append((caption, command,
                               adesklets.context_get_image(),
                               adesklets.image_get_width(),
                               adesklets.image_get_height()))
     
        # Compute the window size
        #
        self._window_width=((self.config['icon_spacing']+
                             self.config['icon_min_width'])*len(self.icons)+
                            (self.config['icon_max_width']-
                             self.config['icon_min_width'])+
                            self.config['icon_spacing'])
        self._window_height=self.config['icon_max_height']
        
        # Set the icon buffer
        #
        self._buffer_icons=adesklets.create_image(self._window_width,
                                                  self._window_height)

        # Load the caption font (if needed), adjusting
        # the window size appropriately
        #
        if self.config['caption_font']:
            adesklets.context_set_font(
                adesklets.load_font('%s/%s' %
                                    (self.config['caption_font'],
                                     str(self.config['caption_size']))))
            dummy, self._caption_height = adesklets.get_text_size('x')
            self._window_height+=self._caption_height

            # Create the caption buffer
            #
            self._buffer_caption=adesklets.create_image(self._window_width,
                                                        self._caption_height)

            # Compute and save final caption color once and for all
            #
            color_base=self.config.color(self.config['caption_color'])
            self._caption_color = color_base + [255]

            # Prepare the fade-in effect
            #
            if self.config['caption_fade_in']:
                adesklets.start_recording()
                time_step = (float(self.config['caption_fade_in_duration'])/
                             self.config['caption_fade_in_steps'])
                fade_step = int(250/self.config['caption_fade_in_steps'])
                for i in range(self.config['caption_fade_in_steps']):
                    adesklets.time_gate((i+1)*time_step)
                    adesklets.context_set_image('$buffer')
                    adesklets.context_set_color(0,0,0,0)
                    adesklets.image_fill_rectangle('$x',0,
                                                   '$width','$height')
                    adesklets.context_set_color(*(color_base+[fade_step*i+5]))
                    adesklets.text_draw('$x',0,'$text')
                    adesklets.context_set_image(0)
                    adesklets.blend_image_onto_image('$buffer',1,
                                                     '$x',0,'$width','$height',
                                                     '$x','$y','$width','$height')
                self._fadein = adesklets.stop_recording()
                adesklets.play_set_abort_on_events(True)
                
            # Set the 'y' and 'buffer' variables once and for all
            #
            if self.config['caption_above']:
                adesklets.set('y',0)
            else:
                adesklets.set('y',self.config['icon_max_height'])
            adesklets.set('buffer',self._buffer_caption)
        else:
            self._caption_height=0
    
        # Resize the window
        #
        adesklets.window_resize(self._window_width,self._window_height)
        adesklets.context_set_image(0)
        
        # Finish setting things up, then display the window
        #
        adesklets.context_set_blend(False)
        adesklets.window_set_transparency(True)
        adesklets.menu_add_separator()
        adesklets.menu_add_item('Configure')
        self._display_icons()
        adesklets.window_show()

#--- desklet synchronous events management -------------------------------------
    def background_grab(self, delayed):
        """
        Set up the bar background.
        We choosed to work directly on image #1 because
        the operation is always setting the same pixels,
        so there is no real flickering, just a delay.
        """
        if self.config['bar_height']>0:
            # Compute rectangle dimensions
            #
            coords=[0,(self.config['icon_max_height']-
                       self.config['bar_height'])/2,
                    self._window_width,self.config['bar_height']]
            if self.config['caption_above']:
                coords[1]+=self._caption_height

            # Draw it
            #
            adesklets.context_set_blend(True)
            adesklets.context_set_image(1)
            if self.config['bar_background_1']:
                adesklets.context_set_color(
                    *(self.config.color(self.config['bar_background_1'])+
                      [self.config['bar_opacity_1']]))
                if self.config['bar_background_2']:
                    adesklets.context_set_color_range(
                        adesklets.create_color_range())
                    adesklets.add_color_to_color_range(0)
                    adesklets.context_set_color(
                        *(self.config.color(self.config['bar_background_2'])+
                          [self.config['bar_opacity_2']]))
                    adesklets.add_color_to_color_range(self._window_width)
                    adesklets.image_fill_color_range_rectangle(
                        *(coords+[self.config['bar_gradient_angle']]))
                    adesklets.free_color_range(0)
                else:
                    adesklets.image_fill_rectangle(*coords)
            if self.config['bar_foreground']:
                adesklets.context_set_color(
                    *(self.config.color(self.config['bar_foreground']+'FF')))
                adesklets.image_draw_rectangle(*coords)
                
            adesklets.context_set_blend(False)
        
    def menu_fire(self, delayed, menu_id, item):
        if item=='Configure':
            editor=getenv('EDITOR')
            if editor:
                self._execute('xterm -e %s ' % editor +
                              join(self.basedir,'config.txt'))

    def button_press(self, delayed, x, y, button):
        if button==1:
            active, scaling = self._get_active_and_scaling(x)
            if active in range(len(self.icons)):
                if self.config['click_effect']:
                    if self.config['caption_font'] and \
                           self.config['caption_above']:
                        y = self._caption_height
                    else:
                        y = 0
                    adesklets.context_set_image(self.icons[active][2])
                    image=adesklets.clone_image()
                    adesklets.context_set_image(image)
                    adesklets.apply_filter(self.config['click_effect'])
                    adesklets.context_set_image(0)
                    adesklets.blend_image_onto_image(image,1,\
                       0,0,self.icons[active][3],self.icons[active][4],
                       *map(lambda x: x[0]+x[1],
                           zip([0,y,0,0],self._position(active,x))))
                    adesklets.free_image(image)
                    sleep(max(self.config['click_effect_duration'],.01))
                    adesklets.context_set_blend(False)
                    self._display_icons(x)
                self._execute(self.icons[active][1])

    def motion_notify(self, delayed, x, y):
        if not delayed:
            if self.config['icon_max_width']!= \
                   self.config['icon_min_width']:
                self._display_icons(x)
        else:
            self._active, scaling = self._get_active_and_scaling(x)
        self._moved=True

    def leave_notify(self, delayed, x, y):
        self._active=None
        self._display_icons()
        self._display_caption()
        
#--- desklet asynchronous events management ------------------------------------
    def pause(self):
        """
        Overrides the pause method from the base class:
        the caption fading effect is called from here,
        since it has to be asynchonous from events.
        """
        active_old=-1
        while True:
            self.block()
            if self._active!=active_old and \
                   self._active in range(len(self.icons)):
                self._display_caption()
            active_old=self._active
            self.unblock()
            
            if self.config['caption_delay']!=0:
                time_initial=time()
                while self._moved or (time()-time_initial <
                                      max(self.config['caption_delay'],.1)):
                    self.block()
                    if self._moved:
                        time_initial=time()
                        self._moved=False
                    self.unblock()
                    sleep(max((max(self.config['caption_delay'],.1)-
                               (time()-time_initial)),.01))
            else:
                while not self._moved:
                    sleep(1)
                self._moved=False
                
#--- desklets drawing utility functions ----------------------------------------
    def _display_icons(self, x=0):
        """
        Note: this routine will only make change to the icons
        part of final image, stored as self._buffer.
        Changing caption is the job of _display_caption, that
        does the job right onto the foreground image
        """
        # Sweep the buffer image
        #
        adesklets.context_set_image(self._buffer_icons)
        adesklets.context_set_color(0,0,0,0)
        adesklets.image_fill_rectangle(0,0,self._window_width,
                                       self.config['icon_max_height'])
        
        # Then reload the icons onto it one by one
        #
        for rank in range(len(self.icons)):
            adesklets.blend_image_onto_image(self.icons[rank][2],1,
                                             0,0,
                                             self.icons[rank][3],
                                             self.icons[rank][4],
                                             *self._position(rank,x))

        # Copy this new image on the foreground
        #
        if self.config['caption_font'] and self.config['caption_above']:
            y = self._caption_height
        else:
            y = 0
        adesklets.context_set_image(0)
        adesklets.blend_image_onto_image(self._buffer_icons,1,
                                         0, 0,
                                         self._window_width,
                                         self.config['icon_max_height'],
                                         0, y,
                                         self._window_width,
                                         self.config['icon_max_height'])

    def _display_caption(self):
        if self.config['caption_font']:
            # Sweep buffer caption clean
            #
            adesklets.context_set_image(self._buffer_caption)
            adesklets.context_set_color(0,0,0,0)
            adesklets.image_fill_rectangle(0,0,
                                           self._window_width,
                                           self._caption_height)
            
            if self._active in range(len(self.icons)) and \
                   len(self.icons[self._active][0])>0:
                # Compute final text position
                #
                width, height = adesklets.get_text_size(
                    self.icons[self._active][0])
                pos = self._position(self._active, -1, False)
                x = (pos[0]+pos[2]/2)-width/2
                if x+width>self._window_width: x=self._window_width-x
                if x<0: x=0
                
                # If turned on, performs the caption fade-in
                #
                if self.config['caption_fade_in']:
                    # Sweep window buffer space
                    #
                    adesklets.context_set_image(0)
                    adesklets.blend_image_onto_image(self._buffer_caption,1,
                                                     0,0,
                                                     self._window_width,
                                                     self._caption_height,
                                                     0,adesklets.echo('$y'),
                                                     self._window_width,
                                                     self._caption_height)
                    
                    # Set variables and execute the fade in
                    #
                    adesklets.set('text',self.icons[self._active][0])
                    adesklets.set('x',x)
                    adesklets.set('width',width)
                    adesklets.set('height',height) 
                    adesklets.play(*self._fadein)
                    
                # Force final result, regardless the previous state
                #
                adesklets.context_set_image(self._buffer_caption)
                adesklets.context_set_color(*self._caption_color)
                adesklets.text_draw(x,0,self.icons[self._active][0])
            
            # Render final result on caption buffer
            #
            adesklets.context_set_image(0)    
            adesklets.blend_image_onto_image(self._buffer_caption,1,
                                             0,0,
                                             self._window_width,
                                             self._caption_height,
                                             0,adesklets.echo('$y'),
                                             self._window_width,
                                             self._caption_height)
                
        
    def _position(self, rank, x, compute_active=True):
        """
        Compute the icon final coordinates and size
        """

        # First, compute the active icon rank, scaling and dimensions
        # the 'rank==0' clause is only a performance tuning:
        # since _position is usually called for a sequence of icons
        # (see _display_icons), it is usefull not to recompute
        # these parameters for every icon.
        #
        # Yes, I know, this should be a generator; the thing is it is
        # also called from time to time (only once) from _display_caption
        #
        if rank==0:
                active, scaling = self._get_active_and_scaling(x)
                active_width = int(scaling * self.config['icon_max_width'] +
                                   (1-scaling) * self.config['icon_min_width'])
                active_height = int(scaling * self.config['icon_max_height'] +
                                    (1-scaling) * self.config['icon_min_height'])
                if compute_active:
                    self._active, self._active_width, self._active_height = \
                                  (active, active_width, active_height)
        else:
            active, active_width, active_height = \
                    (self._active, self._active_width, self._active_height)

        # Override previous variable load for 
        if not compute_active:
            active, active_width, active_height = (-1,0,0)

        x=(self.config['icon_spacing']+
             (self.config['icon_max_width']-self.config['icon_min_width'])/2 +
             (self.config['icon_spacing']+self.config['icon_min_width'])*rank)
        y=(self.config['icon_max_height']-self.config['icon_min_height'])/2
        if active in range(len(self.icons)):
            if rank>active:
                x+=(active_width-self.config['icon_min_width'])/2
            else:
                if rank<=active:
                    x-=(active_width-self.config['icon_min_width'])/2
                if rank==active:
                  y-=(active_height-self.config['icon_min_width'])/2  

	if rank!=active:
            return (x, y,
                    self.config['icon_min_width'],
                    self.config['icon_min_height'])
        else:
            return (x, y,
                    active_width, active_height)
            
    def _get_active_and_scaling(self,x):
        """
        Compute what icon the mouse is over, as well as the scaling factor
        """
        scaling=1-2*abs((((x-self.config['icon_spacing']-
                           ((self.config['icon_max_width']-
                             self.config['icon_min_width'])/2))%
                          (self.config['icon_min_width']+
                           self.config['icon_spacing']))-
                         ((self.config['icon_min_width']+
                           self.config['icon_spacing'])/2))/
                        float(self.config['icon_min_width']+
                              self.config['icon_spacing']))
        if scaling>=self.config['icon_maximize_threshold']: scaling=1
        return ((x-self.config['icon_spacing']-
                 ((self.config['icon_max_width']-
                   self.config['icon_min_width'])/2))/
                (self.config['icon_min_width']+self.config['icon_spacing']),
                scaling)

    def _execute(self, command):
        spawnlp(P_NOWAIT, command.split()[0], *command.split())
   
#-------------------------------------------------------------------------------
# Now, let's start everything
#
if hasattr(adesklets,'version_check'):
    Events(dirname(__file__)).pause()
else:
    raise RuntimeError, 'You need adesklets >= 0.3.1. See README.'
